/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/js/nestable.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports) {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n//# sourceURL=webpack:///./node_modules/process/browser.js?");

/***/ }),

/***/ "./node_modules/setimmediate/setImmediate.js":
/*!***************************************************!*\
  !*** ./node_modules/setimmediate/setImmediate.js ***!
  \***************************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {\n    \"use strict\";\n\n    if (global.setImmediate) {\n        return;\n    }\n\n    var nextHandle = 1; // Spec says greater than zero\n    var tasksByHandle = {};\n    var currentlyRunningATask = false;\n    var doc = global.document;\n    var registerImmediate;\n\n    function setImmediate(callback) {\n      // Callback can either be a function or a string\n      if (typeof callback !== \"function\") {\n        callback = new Function(\"\" + callback);\n      }\n      // Copy function arguments\n      var args = new Array(arguments.length - 1);\n      for (var i = 0; i < args.length; i++) {\n          args[i] = arguments[i + 1];\n      }\n      // Store and register the task\n      var task = { callback: callback, args: args };\n      tasksByHandle[nextHandle] = task;\n      registerImmediate(nextHandle);\n      return nextHandle++;\n    }\n\n    function clearImmediate(handle) {\n        delete tasksByHandle[handle];\n    }\n\n    function run(task) {\n        var callback = task.callback;\n        var args = task.args;\n        switch (args.length) {\n        case 0:\n            callback();\n            break;\n        case 1:\n            callback(args[0]);\n            break;\n        case 2:\n            callback(args[0], args[1]);\n            break;\n        case 3:\n            callback(args[0], args[1], args[2]);\n            break;\n        default:\n            callback.apply(undefined, args);\n            break;\n        }\n    }\n\n    function runIfPresent(handle) {\n        // From the spec: \"Wait until any invocations of this algorithm started before this one have completed.\"\n        // So if we're currently running a task, we'll need to delay this invocation.\n        if (currentlyRunningATask) {\n            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n            // \"too much recursion\" error.\n            setTimeout(runIfPresent, 0, handle);\n        } else {\n            var task = tasksByHandle[handle];\n            if (task) {\n                currentlyRunningATask = true;\n                try {\n                    run(task);\n                } finally {\n                    clearImmediate(handle);\n                    currentlyRunningATask = false;\n                }\n            }\n        }\n    }\n\n    function installNextTickImplementation() {\n        registerImmediate = function(handle) {\n            process.nextTick(function () { runIfPresent(handle); });\n        };\n    }\n\n    function canUsePostMessage() {\n        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n        // where `global.postMessage` means something completely different and can't be used for this purpose.\n        if (global.postMessage && !global.importScripts) {\n            var postMessageIsAsynchronous = true;\n            var oldOnMessage = global.onmessage;\n            global.onmessage = function() {\n                postMessageIsAsynchronous = false;\n            };\n            global.postMessage(\"\", \"*\");\n            global.onmessage = oldOnMessage;\n            return postMessageIsAsynchronous;\n        }\n    }\n\n    function installPostMessageImplementation() {\n        // Installs an event handler on `global` for the `message` event: see\n        // * https://developer.mozilla.org/en/DOM/window.postMessage\n        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n\n        var messagePrefix = \"setImmediate$\" + Math.random() + \"$\";\n        var onGlobalMessage = function(event) {\n            if (event.source === global &&\n                typeof event.data === \"string\" &&\n                event.data.indexOf(messagePrefix) === 0) {\n                runIfPresent(+event.data.slice(messagePrefix.length));\n            }\n        };\n\n        if (global.addEventListener) {\n            global.addEventListener(\"message\", onGlobalMessage, false);\n        } else {\n            global.attachEvent(\"onmessage\", onGlobalMessage);\n        }\n\n        registerImmediate = function(handle) {\n            global.postMessage(messagePrefix + handle, \"*\");\n        };\n    }\n\n    function installMessageChannelImplementation() {\n        var channel = new MessageChannel();\n        channel.port1.onmessage = function(event) {\n            var handle = event.data;\n            runIfPresent(handle);\n        };\n\n        registerImmediate = function(handle) {\n            channel.port2.postMessage(handle);\n        };\n    }\n\n    function installReadyStateChangeImplementation() {\n        var html = doc.documentElement;\n        registerImmediate = function(handle) {\n            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n            var script = doc.createElement(\"script\");\n            script.onreadystatechange = function () {\n                runIfPresent(handle);\n                script.onreadystatechange = null;\n                html.removeChild(script);\n                script = null;\n            };\n            html.appendChild(script);\n        };\n    }\n\n    function installSetTimeoutImplementation() {\n        registerImmediate = function(handle) {\n            setTimeout(runIfPresent, 0, handle);\n        };\n    }\n\n    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\n\n    // Don't get fooled by e.g. browserify environments.\n    if ({}.toString.call(global.process) === \"[object process]\") {\n        // For Node.js before 0.9\n        installNextTickImplementation();\n\n    } else if (canUsePostMessage()) {\n        // For non-IE10 modern browsers\n        installPostMessageImplementation();\n\n    } else if (global.MessageChannel) {\n        // For web workers, where supported\n        installMessageChannelImplementation();\n\n    } else if (doc && \"onreadystatechange\" in doc.createElement(\"script\")) {\n        // For IE 6â€“8\n        installReadyStateChangeImplementation();\n\n    } else {\n        // For older browsers\n        installSetTimeoutImplementation();\n    }\n\n    attachTo.setImmediate = setImmediate;\n    attachTo.clearImmediate = clearImmediate;\n}(typeof self === \"undefined\" ? typeof global === \"undefined\" ? this : global : self));\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\"), __webpack_require__(/*! ./../process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///./node_modules/setimmediate/setImmediate.js?");

/***/ }),

/***/ "./node_modules/timers-browserify/main.js":
/*!************************************************!*\
  !*** ./node_modules/timers-browserify/main.js ***!
  \************************************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {var scope = (typeof global !== \"undefined\" && global) ||\n            (typeof self !== \"undefined\" && self) ||\n            window;\nvar apply = Function.prototype.apply;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) {\n  if (timeout) {\n    timeout.close();\n  }\n};\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(scope, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// setimmediate attaches itself to the global object\n__webpack_require__(/*! setimmediate */ \"./node_modules/setimmediate/setImmediate.js\");\n// On some exotic environments, it's not clear which object `setimmediate` was\n// able to install onto.  Search each possibility in the same order as the\n// `setimmediate` library.\nexports.setImmediate = (typeof self !== \"undefined\" && self.setImmediate) ||\n                       (typeof global !== \"undefined\" && global.setImmediate) ||\n                       (this && this.setImmediate);\nexports.clearImmediate = (typeof self !== \"undefined\" && self.clearImmediate) ||\n                         (typeof global !== \"undefined\" && global.clearImmediate) ||\n                         (this && this.clearImmediate);\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./node_modules/timers-browserify/main.js?");

/***/ }),

/***/ "./node_modules/uikit/src/js/util/lang.js":
/*!************************************************!*\
  !*** ./node_modules/uikit/src/js/util/lang.js ***!
  \************************************************/
/*! exports provided: bind, hasOwn, hyphenate, camelize, ucfirst, startsWith, endsWith, includes, isArray, isFunction, isObject, isPlainObject, isWindow, isDocument, isJQuery, isNode, isNodeCollection, isBoolean, isString, isNumber, isNumeric, isUndefined, toBoolean, toNumber, toFloat, toNode, toNodes, toList, toMs, swap, assign, each, sortBy, clamp, noop, intersectRect, pointInRect, Dimensions */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"bind\", function() { return bind; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"hasOwn\", function() { return hasOwn; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"hyphenate\", function() { return hyphenate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"camelize\", function() { return camelize; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ucfirst\", function() { return ucfirst; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"startsWith\", function() { return startsWith; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"endsWith\", function() { return endsWith; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"includes\", function() { return includes; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isArray\", function() { return isArray; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isFunction\", function() { return isFunction; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isObject\", function() { return isObject; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isPlainObject\", function() { return isPlainObject; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isWindow\", function() { return isWindow; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isDocument\", function() { return isDocument; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isJQuery\", function() { return isJQuery; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isNode\", function() { return isNode; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isNodeCollection\", function() { return isNodeCollection; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isBoolean\", function() { return isBoolean; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isString\", function() { return isString; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isNumber\", function() { return isNumber; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isNumeric\", function() { return isNumeric; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isUndefined\", function() { return isUndefined; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"toBoolean\", function() { return toBoolean; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"toNumber\", function() { return toNumber; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"toFloat\", function() { return toFloat; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"toNode\", function() { return toNode; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"toNodes\", function() { return toNodes; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"toList\", function() { return toList; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"toMs\", function() { return toMs; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"swap\", function() { return swap; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"assign\", function() { return assign; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"each\", function() { return each; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sortBy\", function() { return sortBy; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"clamp\", function() { return clamp; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"noop\", function() { return noop; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"intersectRect\", function() { return intersectRect; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"pointInRect\", function() { return pointInRect; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Dimensions\", function() { return Dimensions; });\nfunction bind(fn, context) {\n    return function (a) {\n        const l = arguments.length;\n        return l ? l > 1 ? fn.apply(context, arguments) : fn.call(context, a) : fn.call(context);\n    };\n}\n\nconst objPrototype = Object.prototype;\nconst {hasOwnProperty} = objPrototype;\n\nfunction hasOwn(obj, key) {\n    return hasOwnProperty.call(obj, key);\n}\n\nconst hyphenateCache = {};\nconst hyphenateRe = /([a-z\\d])([A-Z])/g;\n\nfunction hyphenate(str) {\n\n    if (!(str in hyphenateCache)) {\n        hyphenateCache[str] = str\n            .replace(hyphenateRe, '$1-$2')\n            .toLowerCase();\n    }\n\n    return hyphenateCache[str];\n}\n\nconst camelizeRe = /-(\\w)/g;\n\nfunction camelize(str) {\n    return str.replace(camelizeRe, toUpper);\n}\n\nfunction toUpper(_, c) {\n    return c ? c.toUpperCase() : '';\n}\n\nfunction ucfirst(str) {\n    return str.length ? toUpper(null, str.charAt(0)) + str.slice(1) : '';\n}\n\nconst strPrototype = String.prototype;\nconst startsWithFn = strPrototype.startsWith || function (search) { return this.lastIndexOf(search, 0) === 0; };\n\nfunction startsWith(str, search) {\n    return startsWithFn.call(str, search);\n}\n\nconst endsWithFn = strPrototype.endsWith || function (search) { return this.substr(-search.length) === search; };\n\nfunction endsWith(str, search) {\n    return endsWithFn.call(str, search);\n}\n\nconst includesFn = function (search) { return ~this.indexOf(search); };\nconst includesStr = strPrototype.includes || includesFn;\nconst includesArray = Array.prototype.includes || includesFn;\n\nfunction includes(obj, search) {\n    return obj && (isString(obj) ? includesStr : includesArray).call(obj, search);\n}\n\nconst {isArray} = Array;\n\nfunction isFunction(obj) {\n    return typeof obj === 'function';\n}\n\nfunction isObject(obj) {\n    return obj !== null && typeof obj === 'object';\n}\n\nfunction isPlainObject(obj) {\n    return isObject(obj) && Object.getPrototypeOf(obj) === objPrototype;\n}\n\nfunction isWindow(obj) {\n    return isObject(obj) && obj === obj.window;\n}\n\nfunction isDocument(obj) {\n    return isObject(obj) && obj.nodeType === 9;\n}\n\nfunction isJQuery(obj) {\n    return isObject(obj) && !!obj.jquery;\n}\n\nfunction isNode(obj) {\n    return obj instanceof Node || isObject(obj) && obj.nodeType >= 1;\n}\n\nconst {toString} = objPrototype;\nfunction isNodeCollection(obj) {\n    return toString.call(obj).match(/^\\[object (NodeList|HTMLCollection)\\]$/);\n}\n\nfunction isBoolean(value) {\n    return typeof value === 'boolean';\n}\n\nfunction isString(value) {\n    return typeof value === 'string';\n}\n\nfunction isNumber(value) {\n    return typeof value === 'number';\n}\n\nfunction isNumeric(value) {\n    return isNumber(value) || isString(value) && !isNaN(value - parseFloat(value));\n}\n\nfunction isUndefined(value) {\n    return value === void 0;\n}\n\nfunction toBoolean(value) {\n    return isBoolean(value)\n        ? value\n        : value === 'true' || value === '1' || value === ''\n            ? true\n            : value === 'false' || value === '0'\n                ? false\n                : value;\n}\n\nfunction toNumber(value) {\n    const number = Number(value);\n    return !isNaN(number) ? number : false;\n}\n\nfunction toFloat(value) {\n    return parseFloat(value) || 0;\n}\n\nfunction toNode(element) {\n    return isNode(element) || isWindow(element) || isDocument(element)\n        ? element\n        : isNodeCollection(element) || isJQuery(element)\n            ? element[0]\n            : isArray(element)\n                ? toNode(element[0])\n                : null;\n}\n\nconst arrayProto = Array.prototype;\nfunction toNodes(element) {\n    return isNode(element)\n        ? [element]\n        : isNodeCollection(element)\n            ? arrayProto.slice.call(element)\n            : isArray(element)\n                ? element.map(toNode).filter(Boolean)\n                : isJQuery(element)\n                    ? element.toArray()\n                    : [];\n}\n\nfunction toList(value) {\n    return isArray(value)\n        ? value\n        : isString(value)\n            ? value.split(/,(?![^(]*\\))/).map(value => isNumeric(value)\n                ? toNumber(value)\n                : toBoolean(value.trim()))\n            : [value];\n}\n\nfunction toMs(time) {\n    return !time\n        ? 0\n        : endsWith(time, 'ms')\n            ? toFloat(time)\n            : toFloat(time) * 1000;\n}\n\nfunction swap(value, a, b) {\n    return value.replace(new RegExp(`${a}|${b}`, 'mg'), match => {\n        return match === a ? b : a;\n    });\n}\n\nconst assign = Object.assign || function (target, ...args) {\n    target = Object(target);\n    for (let i = 0; i < args.length; i++) {\n        const source = args[i];\n        if (source !== null) {\n            for (const key in source) {\n                if (hasOwn(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n    }\n    return target;\n};\n\nfunction each(obj, cb) {\n    for (const key in obj) {\n        cb.call(obj[key], obj[key], key);\n    }\n}\n\nfunction sortBy(collection, prop) {\n    return collection.sort((a, b) =>\n        a[prop] > b[prop]\n            ? 1\n            : b[prop] > a[prop]\n                ? -1\n                : 0\n    );\n}\n\nfunction clamp(number, min = 0, max = 1) {\n    return Math.min(Math.max(number, min), max);\n}\n\nfunction noop() {}\n\nfunction intersectRect(r1, r2) {\n    return r1.left < r2.right &&\n        r1.right > r2.left &&\n        r1.top < r2.bottom &&\n        r1.bottom > r2.top;\n}\n\nfunction pointInRect(point, rect) {\n    return point.x <= rect.right &&\n        point.x >= rect.left &&\n        point.y <= rect.bottom &&\n        point.y >= rect.top;\n}\n\nconst Dimensions = {\n\n    ratio(dimensions, prop, value) {\n\n        const aProp = prop === 'width' ? 'height' : 'width';\n\n        return {\n            [aProp]: dimensions[prop] ? Math.round(value * dimensions[aProp] / dimensions[prop]) : dimensions[aProp],\n            [prop]: value\n        };\n    },\n\n    contain(dimensions, maxDimensions) {\n        dimensions = assign({}, dimensions);\n\n        each(dimensions, (_, prop) => dimensions = dimensions[prop] > maxDimensions[prop]\n            ? this.ratio(dimensions, prop, maxDimensions[prop])\n            : dimensions\n        );\n\n        return dimensions;\n    },\n\n    cover(dimensions, maxDimensions) {\n        dimensions = this.contain(dimensions, maxDimensions);\n\n        each(dimensions, (_, prop) => dimensions = dimensions[prop] < maxDimensions[prop]\n            ? this.ratio(dimensions, prop, maxDimensions[prop])\n            : dimensions\n        );\n\n        return dimensions;\n    }\n\n};\n\n\n//# sourceURL=webpack:///./node_modules/uikit/src/js/util/lang.js?");

/***/ }),

/***/ "./node_modules/uikit/src/js/util/promise.js":
/*!***************************************************!*\
  !*** ./node_modules/uikit/src/js/util/promise.js ***!
  \***************************************************/
/*! exports provided: Promise, Deferred */
/*! ModuleConcatenation bailout: Module uses injected variables (setImmediate) */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(setImmediate) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Promise\", function() { return Promise; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Deferred\", function() { return Deferred; });\n/* harmony import */ var _lang__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lang */ \"./node_modules/uikit/src/js/util/lang.js\");\n/* global setImmediate */\n\n\nconst Promise = 'Promise' in window ? window.Promise : PromiseFn;\n\nclass Deferred {\n    constructor() {\n        this.promise = new Promise((resolve, reject) => {\n            this.reject = reject;\n            this.resolve = resolve;\n        });\n    }\n}\n\n/**\n * Promises/A+ polyfill v1.1.4 (https://github.com/bramstein/promis)\n */\n\nconst RESOLVED = 0;\nconst REJECTED = 1;\nconst PENDING = 2;\n\nconst async = 'setImmediate' in window ? setImmediate : setTimeout;\n\nfunction PromiseFn(executor) {\n\n    this.state = PENDING;\n    this.value = undefined;\n    this.deferred = [];\n\n    const promise = this;\n\n    try {\n        executor(\n            x => {\n                promise.resolve(x);\n            },\n            r => {\n                promise.reject(r);\n            }\n        );\n    } catch (e) {\n        promise.reject(e);\n    }\n}\n\nPromiseFn.reject = function (r) {\n    return new PromiseFn((resolve, reject) => {\n        reject(r);\n    });\n};\n\nPromiseFn.resolve = function (x) {\n    return new PromiseFn((resolve, reject) => {\n        resolve(x);\n    });\n};\n\nPromiseFn.all = function all(iterable) {\n    return new PromiseFn((resolve, reject) => {\n        const result = [];\n        let count = 0;\n\n        if (iterable.length === 0) {\n            resolve(result);\n        }\n\n        function resolver(i) {\n            return function (x) {\n                result[i] = x;\n                count += 1;\n\n                if (count === iterable.length) {\n                    resolve(result);\n                }\n            };\n        }\n\n        for (let i = 0; i < iterable.length; i += 1) {\n            PromiseFn.resolve(iterable[i]).then(resolver(i), reject);\n        }\n    });\n};\n\nPromiseFn.race = function race(iterable) {\n    return new PromiseFn((resolve, reject) => {\n        for (let i = 0; i < iterable.length; i += 1) {\n            PromiseFn.resolve(iterable[i]).then(resolve, reject);\n        }\n    });\n};\n\nconst p = PromiseFn.prototype;\n\np.resolve = function resolve(x) {\n    const promise = this;\n\n    if (promise.state === PENDING) {\n        if (x === promise) {\n            throw new TypeError('Promise settled with itself.');\n        }\n\n        let called = false;\n\n        try {\n            const then = x && x.then;\n\n            if (x !== null && Object(_lang__WEBPACK_IMPORTED_MODULE_0__[\"isObject\"])(x) && Object(_lang__WEBPACK_IMPORTED_MODULE_0__[\"isFunction\"])(then)) {\n                then.call(\n                    x,\n                    x => {\n                        if (!called) {\n                            promise.resolve(x);\n                        }\n                        called = true;\n                    },\n                    r => {\n                        if (!called) {\n                            promise.reject(r);\n                        }\n                        called = true;\n                    }\n                );\n                return;\n            }\n        } catch (e) {\n            if (!called) {\n                promise.reject(e);\n            }\n            return;\n        }\n\n        promise.state = RESOLVED;\n        promise.value = x;\n        promise.notify();\n    }\n};\n\np.reject = function reject(reason) {\n    const promise = this;\n\n    if (promise.state === PENDING) {\n        if (reason === promise) {\n            throw new TypeError('Promise settled with itself.');\n        }\n\n        promise.state = REJECTED;\n        promise.value = reason;\n        promise.notify();\n    }\n};\n\np.notify = function notify() {\n    async(() => {\n        if (this.state !== PENDING) {\n            while (this.deferred.length) {\n                const [onResolved, onRejected, resolve, reject] = this.deferred.shift();\n\n                try {\n                    if (this.state === RESOLVED) {\n                        if (Object(_lang__WEBPACK_IMPORTED_MODULE_0__[\"isFunction\"])(onResolved)) {\n                            resolve(onResolved.call(undefined, this.value));\n                        } else {\n                            resolve(this.value);\n                        }\n                    } else if (this.state === REJECTED) {\n                        if (Object(_lang__WEBPACK_IMPORTED_MODULE_0__[\"isFunction\"])(onRejected)) {\n                            resolve(onRejected.call(undefined, this.value));\n                        } else {\n                            reject(this.value);\n                        }\n                    }\n                } catch (e) {\n                    reject(e);\n                }\n            }\n        }\n    });\n};\n\np.then = function then(onResolved, onRejected) {\n    return new PromiseFn((resolve, reject) => {\n        this.deferred.push([onResolved, onRejected, resolve, reject]);\n        this.notify();\n    });\n};\n\np.catch = function (onRejected) {\n    return this.then(undefined, onRejected);\n};\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../timers-browserify/main.js */ \"./node_modules/timers-browserify/main.js\").setImmediate))\n\n//# sourceURL=webpack:///./node_modules/uikit/src/js/util/promise.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/*! ModuleConcatenation bailout: Module is not an ECMAScript module */
/***/ (function(module, exports) {

eval("var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1, eval)(\"this\");\r\n} catch (e) {\r\n\t// This works if the window reference is available\r\n\tif (typeof window === \"object\") g = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n//# sourceURL=webpack:///(webpack)/buildin/global.js?");

/***/ }),

/***/ "./src/js/nestable.js":
/*!*****************************************!*\
  !*** ./src/js/nestable.js + 21 modules ***!
  \*****************************************/
/*! no exports provided */
/*! ModuleConcatenation bailout: Cannot concat with ./node_modules/uikit/src/js/util/lang.js because of ./node_modules/uikit/src/js/util/promise.js */
/*! ModuleConcatenation bailout: Cannot concat with ./node_modules/uikit/src/js/util/promise.js (<- Module uses injected variables (setImmediate)) */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("\n// EXTERNAL MODULE: ./node_modules/uikit/src/js/util/lang.js\nvar lang = __webpack_require__(\"./node_modules/uikit/src/js/util/lang.js\");\n\n// CONCATENATED MODULE: ./node_modules/uikit/src/js/util/attr.js\n\n\nfunction attr(element, name, value) {\n\n    if (Object(lang[\"isObject\"])(name)) {\n        for (const key in name) {\n            attr(element, key, name[key]);\n        }\n        return;\n    }\n\n    if (Object(lang[\"isUndefined\"])(value)) {\n        element = Object(lang[\"toNode\"])(element);\n        return element && element.getAttribute(name);\n    } else {\n        Object(lang[\"toNodes\"])(element).forEach(element => {\n\n            if (Object(lang[\"isFunction\"])(value)) {\n                value = value.call(element, attr(element, name));\n            }\n\n            if (value === null) {\n                removeAttr(element, name);\n            } else {\n                element.setAttribute(name, value);\n            }\n        });\n    }\n\n}\n\nfunction hasAttr(element, name) {\n    return Object(lang[\"toNodes\"])(element).some(element => element.hasAttribute(name));\n}\n\nfunction removeAttr(element, name) {\n    element = Object(lang[\"toNodes\"])(element);\n    name.split(' ').forEach(name =>\n        element.forEach(element =>\n            element.removeAttribute(name)\n        )\n    );\n}\n\nfunction attr_data(element, attribute) {\n    for (let i = 0, attrs = [attribute, `data-${attribute}`]; i < attrs.length; i++) {\n        if (hasAttr(element, attrs[i])) {\n            return attr(element, attrs[i]);\n        }\n    }\n}\n\n// CONCATENATED MODULE: ./node_modules/uikit/src/js/util/selector.js\n\n\n\nfunction query(selector, context) {\n    return Object(lang[\"toNode\"])(selector) || find(selector, getContext(selector, context));\n}\n\nfunction queryAll(selector, context) {\n    const nodes = Object(lang[\"toNodes\"])(selector);\n    return nodes.length && nodes || findAll(selector, getContext(selector, context));\n}\n\nfunction getContext(selector, context = document) {\n    return isContextSelector(selector) || Object(lang[\"isDocument\"])(context)\n        ? context\n        : context.ownerDocument;\n}\n\nfunction find(selector, context) {\n    return Object(lang[\"toNode\"])(_query(selector, context, 'querySelector'));\n}\n\nfunction findAll(selector, context) {\n    return Object(lang[\"toNodes\"])(_query(selector, context, 'querySelectorAll'));\n}\n\nfunction _query(selector, context = document, queryFn) {\n\n    if (!selector || !Object(lang[\"isString\"])(selector)) {\n        return null;\n    }\n\n    selector = selector.replace(contextSanitizeRe, '$1 *');\n\n    let removes;\n\n    if (isContextSelector(selector)) {\n\n        removes = [];\n\n        selector = selector.split(',').map((selector, i) => {\n\n            let ctx = context;\n\n            selector = selector.trim();\n\n            if (selector[0] === '!') {\n\n                const selectors = selector.substr(1).trim().split(' ');\n                ctx = closest(context.parentNode, selectors[0]);\n                selector = selectors.slice(1).join(' ').trim();\n\n            }\n\n            if (selector[0] === '-') {\n\n                const selectors = selector.substr(1).trim().split(' ');\n                const prev = (ctx || context).previousElementSibling;\n                ctx = selector_matches(prev, selector.substr(1)) ? prev : null;\n                selector = selectors.slice(1).join(' ');\n\n            }\n\n            if (!ctx) {\n                return null;\n            }\n\n            if (!ctx.id) {\n                ctx.id = `uk-${Date.now()}${i}`;\n                removes.push(() => removeAttr(ctx, 'id'));\n            }\n\n            return `#${selector_escape(ctx.id)} ${selector}`;\n\n        }).filter(Boolean).join(',');\n\n        context = document;\n\n    }\n\n    try {\n\n        return context[queryFn](selector);\n\n    } catch (e) {\n\n        return null;\n\n    } finally {\n\n        removes && removes.forEach(remove => remove());\n\n    }\n\n}\n\nconst contextSelectorRe = /(^|,)\\s*[!>+~-]/;\nconst contextSanitizeRe = /([!>+~-])(?=\\s+[!>+~-]|\\s*$)/g;\n\nfunction isContextSelector(selector) {\n    return Object(lang[\"isString\"])(selector) && selector.match(contextSelectorRe);\n}\n\nconst elProto = Element.prototype;\nconst matchesFn = elProto.matches || elProto.webkitMatchesSelector || elProto.msMatchesSelector;\n\nfunction selector_matches(element, selector) {\n    return Object(lang[\"toNodes\"])(element).some(element => matchesFn.call(element, selector));\n}\n\nconst closestFn = elProto.closest || function (selector) {\n    let ancestor = this;\n\n    do {\n\n        if (selector_matches(ancestor, selector)) {\n            return ancestor;\n        }\n\n        ancestor = ancestor.parentNode;\n\n    } while (ancestor && ancestor.nodeType === 1);\n};\n\nfunction closest(element, selector) {\n\n    if (Object(lang[\"startsWith\"])(selector, '>')) {\n        selector = selector.slice(1);\n    }\n\n    return Object(lang[\"isNode\"])(element)\n        ? element.parentNode && closestFn.call(element, selector)\n        : Object(lang[\"toNodes\"])(element).map(element => element.parentNode && closestFn.call(element, selector)).filter(Boolean);\n}\n\nfunction parents(element, selector) {\n    const elements = [];\n    let parent = Object(lang[\"toNode\"])(element).parentNode;\n\n    while (parent && parent.nodeType === 1) {\n\n        if (selector_matches(parent, selector)) {\n            elements.push(parent);\n        }\n\n        parent = parent.parentNode;\n    }\n\n    return elements;\n}\n\nconst escapeFn = window.CSS && CSS.escape || function (css) { return css.replace(/([^\\x7f-\\uFFFF\\w-])/g, match => `\\\\${match}`); };\nfunction selector_escape(css) {\n    return Object(lang[\"isString\"])(css) ? escapeFn.call(null, css) : '';\n}\n\n// CONCATENATED MODULE: ./node_modules/uikit/src/js/util/filter.js\n\n\n\nconst voidElements = {\n    area: true,\n    base: true,\n    br: true,\n    col: true,\n    embed: true,\n    hr: true,\n    img: true,\n    input: true,\n    keygen: true,\n    link: true,\n    menuitem: true,\n    meta: true,\n    param: true,\n    source: true,\n    track: true,\n    wbr: true\n};\nfunction isVoidElement(element) {\n    return Object(lang[\"toNodes\"])(element).some(element => voidElements[element.tagName.toLowerCase()]);\n}\n\nfunction isVisible(element) {\n    return Object(lang[\"toNodes\"])(element).some(element => element.offsetWidth || element.offsetHeight || element.getClientRects().length);\n}\n\nconst selInput = 'input,select,textarea,button';\nfunction isInput(element) {\n    return Object(lang[\"toNodes\"])(element).some(element => selector_matches(element, selInput));\n}\n\nfunction filter(element, selector) {\n    return Object(lang[\"toNodes\"])(element).filter(element => selector_matches(element, selector));\n}\n\nfunction within(element, selector) {\n    return !Object(lang[\"isString\"])(selector)\n        ? element === selector || (Object(lang[\"isDocument\"])(selector)\n            ? selector.documentElement\n            : Object(lang[\"toNode\"])(selector)).contains(Object(lang[\"toNode\"])(element)) // IE 11 document does not implement contains\n        : selector_matches(element, selector) || closest(element, selector);\n}\n\n// CONCATENATED MODULE: ./node_modules/uikit/src/js/util/event.js\n\n\n\n\nfunction on(...args) {\n\n    let [targets, type, selector, listener, useCapture] = getArgs(args);\n\n    targets = toEventTargets(targets);\n\n    if (selector) {\n        listener = event_delegate(targets, selector, listener);\n    }\n\n    if (listener.length > 1) {\n        listener = event_detail(listener);\n    }\n\n    type.split(' ').forEach(type =>\n        targets.forEach(target =>\n            target.addEventListener(type, listener, useCapture)\n        )\n    );\n    return () => off(targets, type, listener, useCapture);\n}\n\nfunction off(targets, type, listener, useCapture = false) {\n    targets = toEventTargets(targets);\n    type.split(' ').forEach(type =>\n        targets.forEach(target =>\n            target.removeEventListener(type, listener, useCapture)\n        )\n    );\n}\n\nfunction once(...args) {\n\n    const [element, type, selector, listener, useCapture, condition] = getArgs(args);\n    const off = on(element, type, selector, e => {\n        const result = !condition || condition(e);\n        if (result) {\n            off();\n            listener(e, result);\n        }\n    }, useCapture);\n\n    return off;\n}\n\nfunction trigger(targets, event, detail) {\n    return toEventTargets(targets).reduce((notCanceled, target) =>\n        notCanceled && target.dispatchEvent(createEvent(event, true, true, detail))\n        , true);\n}\n\nfunction createEvent(e, bubbles = true, cancelable = false, detail) {\n    if (Object(lang[\"isString\"])(e)) {\n        const event = document.createEvent('CustomEvent'); // IE 11\n        event.initCustomEvent(e, bubbles, cancelable, detail);\n        e = event;\n    }\n\n    return e;\n}\n\nfunction getArgs(args) {\n    if (Object(lang[\"isFunction\"])(args[2])) {\n        args.splice(2, 0, false);\n    }\n    return args;\n}\n\nfunction event_delegate(delegates, selector, listener) {\n    return e => {\n\n        delegates.forEach(delegate => {\n\n            const current = selector[0] === '>'\n                ? findAll(selector, delegate).reverse().filter(element => within(e.target, element))[0]\n                : closest(e.target, selector);\n\n            if (current) {\n                e.delegate = delegate;\n                e.current = current;\n\n                listener.call(this, e);\n            }\n\n        });\n\n    };\n}\n\nfunction event_detail(listener) {\n    return e => Object(lang[\"isArray\"])(e.detail) ? listener(...[e].concat(e.detail)) : listener(e);\n}\n\nfunction isEventTarget(target) {\n    return target && 'addEventListener' in target;\n}\n\nfunction toEventTarget(target) {\n    return isEventTarget(target) ? target : Object(lang[\"toNode\"])(target);\n}\n\nfunction toEventTargets(target) {\n    return Object(lang[\"isArray\"])(target)\n            ? target.map(toEventTarget).filter(Boolean)\n            : Object(lang[\"isString\"])(target)\n                ? findAll(target)\n                : isEventTarget(target)\n                    ? [target]\n                    : Object(lang[\"toNodes\"])(target);\n}\n\nfunction preventClick() {\n\n    const timer = setTimeout(once(document, 'click', e => {\n\n        e.preventDefault();\n        e.stopImmediatePropagation();\n\n        clearTimeout(timer);\n\n    }, true));\n\n    trigger(document, 'touchcancel');\n\n}\n\n// EXTERNAL MODULE: ./node_modules/uikit/src/js/util/promise.js\nvar util_promise = __webpack_require__(\"./node_modules/uikit/src/js/util/promise.js\");\n\n// CONCATENATED MODULE: ./node_modules/uikit/src/js/util/ajax.js\n\n\n\n\nfunction ajax(url, options) {\n    return new util_promise[\"Promise\"]((resolve, reject) => {\n\n        const env = Object(lang[\"assign\"])({\n            data: null,\n            method: 'GET',\n            headers: {},\n            xhr: new XMLHttpRequest(),\n            beforeSend: lang[\"noop\"],\n            responseType: ''\n        }, options);\n\n        env.beforeSend(env);\n\n        const {xhr} = env;\n\n        for (const prop in env) {\n            if (prop in xhr) {\n                try {\n\n                    xhr[prop] = env[prop];\n\n                } catch (e) {}\n            }\n        }\n\n        xhr.open(env.method.toUpperCase(), url);\n\n        for (const header in env.headers) {\n            xhr.setRequestHeader(header, env.headers[header]);\n        }\n\n        on(xhr, 'load', () => {\n\n            if (xhr.status === 0 || xhr.status >= 200 && xhr.status < 300 || xhr.status === 304) {\n                resolve(xhr);\n            } else {\n                reject(Object(lang[\"assign\"])(Error(xhr.statusText), {\n                    xhr,\n                    status: xhr.status\n                }));\n            }\n\n        });\n\n        on(xhr, 'error', () => reject(Object(lang[\"assign\"])(Error('Network Error'), {xhr})));\n        on(xhr, 'timeout', () => reject(Object(lang[\"assign\"])(Error('Network Timeout'), {xhr})));\n\n        xhr.send(env.data);\n    });\n}\n\nfunction getImage(src, srcset, sizes) {\n\n    return new util_promise[\"Promise\"]((resolve, reject) => {\n        const img = new Image();\n\n        img.onerror = reject;\n        img.onload = () => resolve(img);\n\n        sizes && (img.sizes = sizes);\n        srcset && (img.srcset = srcset);\n        img.src = src;\n    });\n\n}\n\n// CONCATENATED MODULE: ./node_modules/uikit/src/js/util/dom.js\n\n\n\nfunction isReady() {\n    return document.readyState === 'complete' || document.readyState !== 'loading' && !document.documentElement.doScroll;\n}\n\nfunction ready(fn) {\n\n    if (isReady()) {\n        fn();\n        return;\n    }\n\n    const handle = function () {\n        unbind1();\n        unbind2();\n        fn();\n    };\n    const unbind1 = on(document, 'DOMContentLoaded', handle);\n    const unbind2 = on(window, 'load', handle);\n}\n\nfunction index(element, ref) {\n    return ref\n        ? Object(lang[\"toNodes\"])(element).indexOf(Object(lang[\"toNode\"])(ref))\n        : Object(lang[\"toNodes\"])((element = Object(lang[\"toNode\"])(element)) && element.parentNode.children).indexOf(element);\n}\n\nfunction getIndex(i, elements, current = 0, finite = false) {\n\n    elements = Object(lang[\"toNodes\"])(elements);\n\n    const {length} = elements;\n\n    i = Object(lang[\"isNumeric\"])(i)\n        ? Object(lang[\"toNumber\"])(i)\n        : i === 'next'\n            ? current + 1\n            : i === 'previous'\n                ? current - 1\n                : index(elements, i);\n\n    if (finite) {\n        return Object(lang[\"clamp\"])(i, 0, length - 1);\n    }\n\n    i %= length;\n\n    return i < 0 ? i + length : i;\n}\n\nfunction empty(element) {\n    element = Object(lang[\"toNode\"])(element);\n    element.innerHTML = '';\n    return element;\n}\n\nfunction dom_html(parent, html) {\n    parent = Object(lang[\"toNode\"])(parent);\n    return Object(lang[\"isUndefined\"])(html)\n        ? parent.innerHTML\n        : append(parent.hasChildNodes() ? empty(parent) : parent, html);\n}\n\nfunction prepend(parent, element) {\n\n    parent = Object(lang[\"toNode\"])(parent);\n\n    if (!parent.hasChildNodes()) {\n        return append(parent, element);\n    } else {\n        return insertNodes(element, element => parent.insertBefore(element, parent.firstChild));\n    }\n}\n\nfunction append(parent, element) {\n    parent = Object(lang[\"toNode\"])(parent);\n    return insertNodes(element, element => parent.appendChild(element));\n}\n\nfunction before(ref, element) {\n    ref = Object(lang[\"toNode\"])(ref);\n    return insertNodes(element, element => ref.parentNode.insertBefore(element, ref));\n}\n\nfunction after(ref, element) {\n    ref = Object(lang[\"toNode\"])(ref);\n    return insertNodes(element, element => ref.nextSibling\n        ? before(ref.nextSibling, element)\n        : append(ref.parentNode, element)\n    );\n}\n\nfunction insertNodes(element, fn) {\n    element = Object(lang[\"isString\"])(element) ? fragment(element) : element;\n    return element\n        ? 'length' in element\n            ? Object(lang[\"toNodes\"])(element).map(fn)\n            : fn(element)\n        : null;\n}\n\nfunction remove(element) {\n    Object(lang[\"toNodes\"])(element).map(element => element.parentNode && element.parentNode.removeChild(element));\n}\n\nfunction wrapAll(element, structure) {\n\n    structure = Object(lang[\"toNode\"])(before(element, structure));\n\n    while (structure.firstChild) {\n        structure = structure.firstChild;\n    }\n\n    append(structure, element);\n\n    return structure;\n}\n\nfunction wrapInner(element, structure) {\n    return Object(lang[\"toNodes\"])(Object(lang[\"toNodes\"])(element).map(element =>\n        element.hasChildNodes ? wrapAll(Object(lang[\"toNodes\"])(element.childNodes), structure) : append(element, structure)\n    ));\n}\n\nfunction unwrap(element) {\n    Object(lang[\"toNodes\"])(element)\n        .map(element => element.parentNode)\n        .filter((value, index, self) => self.indexOf(value) === index)\n        .forEach(parent => {\n            before(parent, parent.childNodes);\n            remove(parent);\n        });\n}\n\nconst fragmentRe = /^\\s*<(\\w+|!)[^>]*>/;\nconst singleTagRe = /^<(\\w+)\\s*\\/?>(?:<\\/\\1>)?$/;\n\nfunction fragment(html) {\n\n    const matches = singleTagRe.exec(html);\n    if (matches) {\n        return document.createElement(matches[1]);\n    }\n\n    const container = document.createElement('div');\n    if (fragmentRe.test(html)) {\n        container.insertAdjacentHTML('beforeend', html.trim());\n    } else {\n        container.textContent = html;\n    }\n\n    return container.childNodes.length > 1 ? Object(lang[\"toNodes\"])(container.childNodes) : container.firstChild;\n\n}\n\nfunction dom_apply(node, fn) {\n\n    if (!node || node.nodeType !== 1) {\n        return;\n    }\n\n    fn(node);\n    node = node.firstElementChild;\n    while (node) {\n        dom_apply(node, fn);\n        node = node.nextElementSibling;\n    }\n}\n\n// CONCATENATED MODULE: ./node_modules/uikit/src/js/util/class.js\n\n\n\nfunction addClass(element, ...args) {\n    class_apply(element, args, 'add');\n}\n\nfunction removeClass(element, ...args) {\n    class_apply(element, args, 'remove');\n}\n\nfunction removeClasses(element, cls) {\n    attr(element, 'class', value => (value || '').replace(new RegExp(`\\\\b${cls}\\\\b`, 'g'), ''));\n}\n\nfunction replaceClass(element, ...args) {\n    args[0] && removeClass(element, args[0]);\n    args[1] && addClass(element, args[1]);\n}\n\nfunction hasClass(element, cls) {\n    return Object(lang[\"toNodes\"])(element).some(element => element.classList.contains(cls));\n}\n\nfunction toggleClass(element, ...args) {\n\n    if (!args.length) {\n        return;\n    }\n\n    args = class_getArgs(args);\n\n    const force = !Object(lang[\"isString\"])(args[args.length - 1]) ? args.pop() : []; // in iOS 9.3 force === undefined evaluates to false\n\n    args = args.filter(Boolean);\n\n    Object(lang[\"toNodes\"])(element).forEach(({classList}) => {\n        for (let i = 0; i < args.length; i++) {\n            supports.Force\n                ? classList.toggle(...[args[i]].concat(force))\n                : (classList[(!Object(lang[\"isUndefined\"])(force) ? force : !classList.contains(args[i])) ? 'add' : 'remove'](args[i]));\n        }\n    });\n\n}\n\nfunction class_apply(element, args, fn) {\n    args = class_getArgs(args).filter(Boolean);\n\n    args.length && Object(lang[\"toNodes\"])(element).forEach(({classList}) => {\n        supports.Multiple\n            ? classList[fn](...args)\n            : args.forEach(cls => classList[fn](cls));\n    });\n}\n\nfunction class_getArgs(args) {\n    return args.reduce((args, arg) =>\n        args.concat.call(args, Object(lang[\"isString\"])(arg) && Object(lang[\"includes\"])(arg, ' ') ? arg.trim().split(' ') : arg)\n        , []);\n}\n\nconst supports = {};\n\n// IE 11\n(function () {\n\n    let list = document.createElement('_').classList;\n    if (list) {\n        list.add('a', 'b');\n        list.toggle('c', false);\n        supports.Multiple = list.contains('b');\n        supports.Force = !list.contains('c');\n    }\n    list = null;\n\n})();\n\n// CONCATENATED MODULE: ./node_modules/uikit/src/js/util/style.js\n\n\n\n\nconst cssNumber = {\n    'animation-iteration-count': true,\n    'column-count': true,\n    'fill-opacity': true,\n    'flex-grow': true,\n    'flex-shrink': true,\n    'font-weight': true,\n    'line-height': true,\n    'opacity': true,\n    'order': true,\n    'orphans': true,\n    'widows': true,\n    'z-index': true,\n    'zoom': true\n};\n\nfunction style_css(element, property, value) {\n\n    return Object(lang[\"toNodes\"])(element).map(element => {\n\n        if (Object(lang[\"isString\"])(property)) {\n\n            property = style_propName(property);\n\n            if (Object(lang[\"isUndefined\"])(value)) {\n                return getStyle(element, property);\n            } else if (!value && value !== 0) {\n                element.style.removeProperty(property);\n            } else {\n                element.style[property] = Object(lang[\"isNumeric\"])(value) && !cssNumber[property] ? `${value}px` : value;\n            }\n\n        } else if (Object(lang[\"isArray\"])(property)) {\n\n            const styles = getStyles(element);\n\n            return property.reduce((props, property) => {\n                props[property] = styles[style_propName(property)];\n                return props;\n            }, {});\n\n        } else if (Object(lang[\"isObject\"])(property)) {\n            Object(lang[\"each\"])(property, (value, property) => style_css(element, property, value));\n        }\n\n        return element;\n\n    })[0];\n\n}\n\nfunction getStyles(element, pseudoElt) {\n    element = Object(lang[\"toNode\"])(element);\n    return element.ownerDocument.defaultView.getComputedStyle(element, pseudoElt);\n}\n\nfunction getStyle(element, property, pseudoElt) {\n    return getStyles(element, pseudoElt)[property];\n}\n\nconst vars = {};\n\nfunction getCssVar(name) {\n\n    if (!(name in vars)) {\n\n        /* usage in css: .var-name:before { content:\"xyz\" } */\n\n        const element = append(document.documentElement, document.createElement('div'));\n\n        addClass(element, `var-${name}`);\n\n        try {\n\n            vars[name] = getStyle(element, 'content', ':before').replace(/^[\"'](.*)[\"']$/, '$1');\n            vars[name] = JSON.parse(vars[name]);\n\n        } catch (e) {}\n\n        document.documentElement.removeChild(element);\n\n    }\n\n    return vars[name];\n\n}\n\nconst cssProps = {};\n\nfunction style_propName(name) {\n\n    let ret = cssProps[name];\n    if (!ret) {\n        ret = cssProps[name] = vendorPropName(name) || name;\n    }\n    return ret;\n}\n\nconst cssPrefixes = ['webkit', 'moz', 'ms'];\nconst {style: style_style} = document.createElement('_');\n\nfunction vendorPropName(name) {\n\n    name = Object(lang[\"hyphenate\"])(name);\n\n    if (name in style_style) {\n        return name;\n    }\n\n    let i = cssPrefixes.length, prefixedName;\n\n    while (i--) {\n        prefixedName = `-${cssPrefixes[i]}-${name}`;\n        if (prefixedName in style_style) {\n            return prefixedName;\n        }\n    }\n}\n\n// CONCATENATED MODULE: ./node_modules/uikit/src/js/util/animation.js\n\n\n\n\n\n\n\nfunction transition(element, props, duration = 400, timing = 'linear') {\n\n    return util_promise[\"Promise\"].all(Object(lang[\"toNodes\"])(element).map(element =>\n        new util_promise[\"Promise\"]((resolve, reject) => {\n\n            for (const name in props) {\n                const value = style_css(element, name);\n                if (value === '') {\n                    style_css(element, name, value);\n                }\n            }\n\n            const timer = setTimeout(() => trigger(element, 'transitionend'), duration);\n\n            once(element, 'transitionend transitioncanceled', ({type}) => {\n                clearTimeout(timer);\n                removeClass(element, 'uk-transition');\n                style_css(element, {\n                    'transition-property': '',\n                    'transition-duration': '',\n                    'transition-timing-function': ''\n                });\n                type === 'transitioncanceled' ? reject() : resolve();\n            }, false, ({target}) => element === target);\n\n            addClass(element, 'uk-transition');\n            style_css(element, Object(lang[\"assign\"])({\n                'transition-property': Object.keys(props).map(style_propName).join(','),\n                'transition-duration': `${duration}ms`,\n                'transition-timing-function': timing\n            }, props));\n\n        })\n    ));\n\n}\n\nconst Transition = {\n\n    start: transition,\n\n    stop(element) {\n        trigger(element, 'transitionend');\n        return util_promise[\"Promise\"].resolve();\n    },\n\n    cancel(element) {\n        trigger(element, 'transitioncanceled');\n    },\n\n    inProgress(element) {\n        return hasClass(element, 'uk-transition');\n    }\n\n};\n\nconst animationPrefix = 'uk-animation-';\nconst clsCancelAnimation = 'uk-cancel-animation';\n\nfunction animate(element, animation, duration = 200, origin, out) {\n\n    return util_promise[\"Promise\"].all(Object(lang[\"toNodes\"])(element).map(element =>\n        new util_promise[\"Promise\"]((resolve, reject) => {\n\n            if (hasClass(element, clsCancelAnimation)) {\n                requestAnimationFrame(() =>\n                    util_promise[\"Promise\"].resolve().then(() =>\n                        animate(...arguments).then(resolve, reject)\n                    )\n                );\n                return;\n            }\n\n            let cls = `${animation} ${animationPrefix}${out ? 'leave' : 'enter'}`;\n\n            if (Object(lang[\"startsWith\"])(animation, animationPrefix)) {\n\n                if (origin) {\n                    cls += ` uk-transform-origin-${origin}`;\n                }\n\n                if (out) {\n                    cls += ` ${animationPrefix}reverse`;\n                }\n\n            }\n\n            reset();\n\n            once(element, 'animationend animationcancel', ({type}) => {\n\n                let hasReset = false;\n\n                if (type === 'animationcancel') {\n                    reject();\n                    reset();\n                } else {\n                    resolve();\n                    util_promise[\"Promise\"].resolve().then(() => {\n                        hasReset = true;\n                        reset();\n                    });\n                }\n\n                requestAnimationFrame(() => {\n                    if (!hasReset) {\n                        addClass(element, clsCancelAnimation);\n\n                        requestAnimationFrame(() => removeClass(element, clsCancelAnimation));\n                    }\n                });\n\n            }, false, ({target}) => element === target);\n\n            style_css(element, 'animationDuration', `${duration}ms`);\n            addClass(element, cls);\n\n            function reset() {\n                style_css(element, 'animationDuration', '');\n                removeClasses(element, `${animationPrefix}\\\\S*`);\n            }\n\n        })\n    ));\n\n}\n\nconst inProgress = new RegExp(`${animationPrefix}(enter|leave)`);\nconst Animation = {\n\n    in(element, animation, duration, origin) {\n        return animate(element, animation, duration, origin, false);\n    },\n\n    out(element, animation, duration, origin) {\n        return animate(element, animation, duration, origin, true);\n    },\n\n    inProgress(element) {\n        return inProgress.test(attr(element, 'class'));\n    },\n\n    cancel(element) {\n        trigger(element, 'animationcancel');\n    }\n\n};\n\n// CONCATENATED MODULE: ./node_modules/uikit/src/js/util/core.js\n\n\n\n\nfunction $(selector, context) {\n    return !Object(lang[\"isString\"])(selector)\n        ? Object(lang[\"toNode\"])(selector)\n        : isHtml(selector)\n            ? Object(lang[\"toNode\"])(fragment(selector))\n            : find(selector, context);\n}\n\nfunction $$(selector, context) {\n    return !Object(lang[\"isString\"])(selector)\n        ? Object(lang[\"toNodes\"])(selector)\n        : isHtml(selector)\n            ? Object(lang[\"toNodes\"])(fragment(selector))\n            : findAll(selector, context);\n}\n\nfunction isHtml(str) {\n    return str[0] === '<' || str.match(/^\\s*</);\n}\n\n// CONCATENATED MODULE: ./node_modules/uikit/src/js/util/dimensions.js\n\n\n\n\n\nconst dirs = {\n    width: ['x', 'left', 'right'],\n    height: ['y', 'top', 'bottom']\n};\n\nfunction positionAt(element, target, elAttach, targetAttach, elOffset, targetOffset, flip, boundary) {\n\n    elAttach = getPos(elAttach);\n    targetAttach = getPos(targetAttach);\n\n    const flipped = {element: elAttach, target: targetAttach};\n\n    if (!element || !target) {\n        return flipped;\n    }\n\n    const dim = getDimensions(element);\n    const targetDim = getDimensions(target);\n    const position = targetDim;\n\n    moveTo(position, elAttach, dim, -1);\n    moveTo(position, targetAttach, targetDim, 1);\n\n    elOffset = getOffsets(elOffset, dim.width, dim.height);\n    targetOffset = getOffsets(targetOffset, targetDim.width, targetDim.height);\n\n    elOffset['x'] += targetOffset['x'];\n    elOffset['y'] += targetOffset['y'];\n\n    position.left += elOffset['x'];\n    position.top += elOffset['y'];\n\n    boundary = getDimensions(boundary || dimensions_window(element));\n\n    if (flip) {\n        Object(lang[\"each\"])(dirs, ([dir, align, alignFlip], prop) => {\n\n            if (!(flip === true || Object(lang[\"includes\"])(flip, dir))) {\n                return;\n            }\n\n            const elemOffset = elAttach[dir] === align\n                ? -dim[prop]\n                : elAttach[dir] === alignFlip\n                    ? dim[prop]\n                    : 0;\n\n            const targetOffset = targetAttach[dir] === align\n                ? targetDim[prop]\n                : targetAttach[dir] === alignFlip\n                    ? -targetDim[prop]\n                    : 0;\n\n            if (position[align] < boundary[align] || position[align] + dim[prop] > boundary[alignFlip]) {\n\n                const centerOffset = dim[prop] / 2;\n                const centerTargetOffset = targetAttach[dir] === 'center' ? -targetDim[prop] / 2 : 0;\n\n                elAttach[dir] === 'center' && (\n                    apply(centerOffset, centerTargetOffset)\n                    || apply(-centerOffset, -centerTargetOffset)\n                ) || apply(elemOffset, targetOffset);\n\n            }\n\n            function apply(elemOffset, targetOffset) {\n\n                const newVal = position[align] + elemOffset + targetOffset - elOffset[dir] * 2;\n\n                if (newVal >= boundary[align] && newVal + dim[prop] <= boundary[alignFlip]) {\n                    position[align] = newVal;\n\n                    ['element', 'target'].forEach((el) => {\n                        flipped[el][dir] = !elemOffset\n                            ? flipped[el][dir]\n                            : flipped[el][dir] === dirs[prop][1]\n                                ? dirs[prop][2]\n                                : dirs[prop][1];\n                    });\n\n                    return true;\n                }\n\n            }\n\n        });\n    }\n\n    dimensions_offset(element, position);\n\n    return flipped;\n}\n\nfunction dimensions_offset(element, coordinates) {\n\n    element = Object(lang[\"toNode\"])(element);\n\n    if (coordinates) {\n\n        const currentOffset = dimensions_offset(element);\n        const pos = style_css(element, 'position');\n\n        ['left', 'top'].forEach(prop => {\n            if (prop in coordinates) {\n                const value = style_css(element, prop);\n                style_css(element, prop, coordinates[prop] - currentOffset[prop]\n                    + Object(lang[\"toFloat\"])(pos === 'absolute' && value === 'auto'\n                        ? dimensions_position(element)[prop]\n                        : value)\n                );\n            }\n        });\n\n        return;\n    }\n\n    return getDimensions(element);\n}\n\nfunction getDimensions(element) {\n\n    element = Object(lang[\"toNode\"])(element);\n\n    const {pageYOffset: top, pageXOffset: left} = dimensions_window(element);\n\n    if (Object(lang[\"isWindow\"])(element)) {\n\n        const height = element.innerHeight;\n        const width = element.innerWidth;\n\n        return {\n            top,\n            left,\n            height,\n            width,\n            bottom: top + height,\n            right: left + width,\n        };\n    }\n\n    let style, hidden;\n\n    if (!isVisible(element)) {\n        style = attr(element, 'style');\n        hidden = attr(element, 'hidden');\n\n        attr(element, {\n            style: `${style || ''};display:block !important;`,\n            hidden: null\n        });\n    }\n\n    const rect = element.getBoundingClientRect();\n\n    if (!Object(lang[\"isUndefined\"])(style)) {\n        attr(element, {style, hidden});\n    }\n\n    return {\n        height: rect.height,\n        width: rect.width,\n        top: rect.top + top,\n        left: rect.left + left,\n        bottom: rect.bottom + top,\n        right: rect.right + left,\n    };\n}\n\nfunction dimensions_position(element) {\n    element = Object(lang[\"toNode\"])(element);\n\n    const parent = element.offsetParent || docEl(element);\n    const parentOffset = dimensions_offset(parent);\n    const {top, left} = ['top', 'left'].reduce((props, prop) => {\n        const propName = Object(lang[\"ucfirst\"])(prop);\n        props[prop] -= parentOffset[prop]\n            + Object(lang[\"toFloat\"])(style_css(element, `margin${propName}`))\n            + Object(lang[\"toFloat\"])(style_css(parent, `border${propName}Width`));\n        return props;\n    }, dimensions_offset(element));\n\n    return {top, left};\n}\n\nconst dimensions_height = dimension('height');\nconst dimensions_width = dimension('width');\n\nfunction dimension(prop) {\n    const propName = Object(lang[\"ucfirst\"])(prop);\n    return (element, value) => {\n\n        element = Object(lang[\"toNode\"])(element);\n\n        if (Object(lang[\"isUndefined\"])(value)) {\n\n            if (Object(lang[\"isWindow\"])(element)) {\n                return element[`inner${propName}`];\n            }\n\n            if (Object(lang[\"isDocument\"])(element)) {\n                const doc = element.documentElement;\n                return Math.max(doc[`offset${propName}`], doc[`scroll${propName}`]);\n            }\n\n            value = style_css(element, prop);\n            value = value === 'auto' ? element[`offset${propName}`] : Object(lang[\"toFloat\"])(value) || 0;\n\n            return value - boxModelAdjust(prop, element);\n\n        } else {\n\n            style_css(element, prop, !value && value !== 0\n                ? ''\n                : +value + boxModelAdjust(prop, element) + 'px'\n            );\n\n        }\n\n    };\n}\n\nfunction boxModelAdjust(prop, element) {\n    return style_css(element, 'boxSizing') === 'border-box'\n        ? dirs[prop].slice(1).map(lang[\"ucfirst\"]).reduce((value, prop) =>\n            value\n            + Object(lang[\"toFloat\"])(style_css(element, `padding${prop}`))\n            + Object(lang[\"toFloat\"])(style_css(element, `border${prop}Width`))\n            , 0)\n        : 0;\n}\n\nfunction moveTo(position, attach, dim, factor) {\n    Object(lang[\"each\"])(dirs, ([dir, align, alignFlip], prop) => {\n        if (attach[dir] === alignFlip) {\n            position[align] += dim[prop] * factor;\n        } else if (attach[dir] === 'center') {\n            position[align] += dim[prop] * factor / 2;\n        }\n    });\n}\n\nfunction getPos(pos) {\n\n    const x = /left|center|right/;\n    const y = /top|center|bottom/;\n\n    pos = (pos || '').split(' ');\n\n    if (pos.length === 1) {\n        pos = x.test(pos[0])\n            ? pos.concat(['center'])\n            : y.test(pos[0])\n                ? ['center'].concat(pos)\n                : ['center', 'center'];\n    }\n\n    return {\n        x: x.test(pos[0]) ? pos[0] : 'center',\n        y: y.test(pos[1]) ? pos[1] : 'center'\n    };\n}\n\nfunction getOffsets(offsets, width, height) {\n\n    const [x, y] = (offsets || '').split(' ');\n\n    return {\n        x: x ? Object(lang[\"toFloat\"])(x) * (Object(lang[\"endsWith\"])(x, '%') ? width / 100 : 1) : 0,\n        y: y ? Object(lang[\"toFloat\"])(y) * (Object(lang[\"endsWith\"])(y, '%') ? height / 100 : 1) : 0\n    };\n}\n\nfunction flipPosition(pos) {\n    switch (pos) {\n        case 'left':\n            return 'right';\n        case 'right':\n            return 'left';\n        case 'top':\n            return 'bottom';\n        case 'bottom':\n            return 'top';\n        default:\n            return pos;\n    }\n}\n\nfunction isInView(element, topOffset = 0, leftOffset = 0, relativeToViewport) {\n\n    if (!isVisible(element)) {\n        return false;\n    }\n\n    element = Object(lang[\"toNode\"])(element);\n\n    const win = dimensions_window(element);\n    let client, bounding;\n\n    if (relativeToViewport) {\n\n        client = element.getBoundingClientRect();\n        bounding = {\n            top: -topOffset,\n            left: -leftOffset,\n            bottom: topOffset + dimensions_height(win),\n            right: leftOffset + dimensions_width(win)\n        };\n\n    } else {\n\n        const [elTop, elLeft] = offsetPosition(element);\n        const {pageYOffset: top, pageXOffset: left} = win;\n\n        client = {\n            top: elTop,\n            left: elLeft,\n            bottom: elTop + element.offsetHeight,\n            right: elTop + element.offsetWidth\n        };\n        bounding = {\n            top: top - topOffset,\n            left: left - leftOffset,\n            bottom: top + topOffset + dimensions_height(win),\n            right: left + leftOffset + dimensions_width(win)\n        };\n    }\n\n    return Object(lang[\"intersectRect\"])(client, bounding) || Object(lang[\"pointInRect\"])({x: client.left, y: client.top}, bounding);\n\n}\n\nfunction scrolledOver(element, heightOffset = 0) {\n\n    if (!isVisible(element)) {\n        return 0;\n    }\n\n    element = Object(lang[\"toNode\"])(element);\n\n    const win = dimensions_window(element);\n    const doc = dimensions_document(element);\n    const elHeight = element.offsetHeight + heightOffset;\n    const [top] = offsetPosition(element);\n    const vp = dimensions_height(win);\n    const vh = vp + Math.min(0, top - vp);\n    const diff = Math.max(0, vp - (dimensions_height(doc) + heightOffset - (top + elHeight)));\n\n    return Object(lang[\"clamp\"])(((vh + win.pageYOffset - top) / ((vh + (elHeight - (diff < vp ? diff : 0))) / 100)) / 100);\n}\n\nfunction scrollTop(element, top) {\n    element = Object(lang[\"toNode\"])(element);\n\n    if (Object(lang[\"isWindow\"])(element) || Object(lang[\"isDocument\"])(element)) {\n        const {scrollTo, pageXOffset} = dimensions_window(element);\n        scrollTo(pageXOffset, top);\n    } else {\n        element.scrollTop = top;\n    }\n}\n\nfunction offsetPosition(element) {\n    const offset = [0, 0];\n\n    do {\n\n        offset[0] += element.offsetTop;\n        offset[1] += element.offsetLeft;\n\n        if (style_css(element, 'position') === 'fixed') {\n            const win = dimensions_window(element);\n            offset[0] += win.pageYOffset;\n            offset[1] += win.pageXOffset;\n            return offset;\n        }\n\n    } while ((element = element.offsetParent));\n\n    return offset;\n}\n\nfunction dimensions_window(element) {\n    return Object(lang[\"isWindow\"])(element) ? element : dimensions_document(element).defaultView;\n}\n\nfunction dimensions_document(element) {\n    return Object(lang[\"toNode\"])(element).ownerDocument;\n}\n\nfunction docEl(element) {\n    return dimensions_document(element).documentElement;\n}\n\n// CONCATENATED MODULE: ./node_modules/uikit/src/js/util/env.js\n/* global DocumentTouch */\n\n\nconst isIE = /msie|trident/i.test(window.navigator.userAgent);\nconst isRtl = attr(document.documentElement, 'dir') === 'rtl';\n\nconst hasTouchEvents = 'ontouchstart' in window;\nconst hasPointerEvents = window.PointerEvent;\nconst hasTouch = hasTouchEvents\n    || window.DocumentTouch && document instanceof DocumentTouch\n    || navigator.maxTouchPoints; // IE >=11\n\nconst pointerDown = !hasTouch ? 'mousedown' : `mousedown ${hasTouchEvents ? 'touchstart' : 'pointerdown'}`;\nconst pointerMove = !hasTouch ? 'mousemove' : `mousemove ${hasTouchEvents ? 'touchmove' : 'pointermove'}`;\nconst pointerUp = !hasTouch ? 'mouseup' : `mouseup ${hasTouchEvents ? 'touchend' : 'pointerup'}`;\nconst pointerEnter = hasTouch && hasPointerEvents ? 'pointerenter' : 'mouseenter';\nconst pointerLeave = hasTouch && hasPointerEvents ? 'pointerleave' : 'mouseleave';\n\n// CONCATENATED MODULE: ./node_modules/uikit/src/js/util/fastdom.js\n/*\n    Based on:\n    Copyright (c) 2016 Wilson Page wilsonpage@me.com\n    https://github.com/wilsonpage/fastdom\n*/\n\nconst fastdom = {\n\n    reads: [],\n    writes: [],\n\n    read(task) {\n        this.reads.push(task);\n        scheduleFlush();\n        return task;\n    },\n\n    write(task) {\n        this.writes.push(task);\n        scheduleFlush();\n        return task;\n    },\n\n    clear(task) {\n        return fastdom_remove(this.reads, task) || fastdom_remove(this.writes, task);\n    },\n\n    flush() {\n\n        runTasks(this.reads);\n        runTasks(this.writes.splice(0, this.writes.length));\n\n        this.scheduled = false;\n\n        if (this.reads.length || this.writes.length) {\n            scheduleFlush();\n        }\n\n    }\n\n};\n\nfunction scheduleFlush() {\n    if (!fastdom.scheduled) {\n        fastdom.scheduled = true;\n        requestAnimationFrame(fastdom.flush.bind(fastdom));\n    }\n}\n\nfunction runTasks(tasks) {\n    let task;\n    while ((task = tasks.shift())) {\n        task();\n    }\n}\n\nfunction fastdom_remove(array, item) {\n    const index = array.indexOf(item);\n    return !!~index && !!array.splice(index, 1);\n}\n\n// CONCATENATED MODULE: ./node_modules/uikit/src/js/util/mouse.js\n\n\n\nfunction MouseTracker() {}\n\nMouseTracker.prototype = {\n\n    positions: [],\n    position: null,\n\n    init() {\n\n        this.positions = [];\n        this.position = null;\n\n        let ticking = false;\n        this.unbind = on(document, 'mousemove', e => {\n\n            if (ticking) {\n                return;\n            }\n\n            setTimeout(() => {\n\n                const time = Date.now();\n                const {length} = this.positions;\n\n                if (length && (time - this.positions[length - 1].time > 100)) {\n                    this.positions.splice(0, length);\n                }\n\n                this.positions.push({time, x: e.pageX, y: e.pageY});\n\n                if (this.positions.length > 5) {\n                    this.positions.shift();\n                }\n\n                ticking = false;\n            }, 5);\n\n            ticking = true;\n        });\n\n    },\n\n    cancel() {\n        if (this.unbind) {\n            this.unbind();\n        }\n    },\n\n    movesTo(target) {\n\n        if (this.positions.length < 2) {\n            return false;\n        }\n\n        const p = dimensions_offset(target);\n        const position = this.positions[this.positions.length - 1];\n        const [prevPos] = this.positions;\n\n        if (p.left <= position.x && position.x <= p.right && p.top <= position.y && position.y <= p.bottom) {\n            return false;\n        }\n\n        const points = [\n            [{x: p.left, y: p.top}, {x: p.right, y: p.bottom}],\n            [{x: p.right, y: p.top}, {x: p.left, y: p.bottom}]\n        ];\n\n        if (p.right <= position.x) {\n            // empty\n        } else if (p.left >= position.x) {\n            points[0].reverse();\n            points[1].reverse();\n        } else if (p.bottom <= position.y) {\n            points[0].reverse();\n        } else if (p.top >= position.y) {\n            points[1].reverse();\n        }\n\n        return !!points.reduce((result, point) => {\n            return result + (slope(prevPos, point[0]) < slope(position, point[0]) && slope(prevPos, point[1]) > slope(position, point[1]));\n        }, 0);\n    }\n\n};\n\nfunction slope(a, b) {\n    return (b.y - a.y) / (b.x - a.x);\n}\n\n// CONCATENATED MODULE: ./node_modules/uikit/src/js/util/options.js\n\n\nconst strats = {};\n\n// concat strategy\nstrats.args =\nstrats.events =\nstrats.init =\nstrats.created =\nstrats.beforeConnect =\nstrats.connected =\nstrats.ready =\nstrats.beforeDisconnect =\nstrats.disconnected =\nstrats.destroy = function (parentVal, childVal) {\n\n    parentVal = parentVal && !Object(lang[\"isArray\"])(parentVal) ? [parentVal] : parentVal;\n\n    return childVal\n        ? parentVal\n            ? parentVal.concat(childVal)\n            : Object(lang[\"isArray\"])(childVal)\n                ? childVal\n                : [childVal]\n        : parentVal;\n};\n\n// update strategy\nstrats.update = function (parentVal, childVal) {\n    return strats.args(parentVal, Object(lang[\"isFunction\"])(childVal) ? {read: childVal} : childVal);\n};\n\n// property strategy\nstrats.props = function (parentVal, childVal) {\n\n    if (Object(lang[\"isArray\"])(childVal)) {\n        childVal = childVal.reduce((value, key) => {\n            value[key] = String;\n            return value;\n        }, {});\n    }\n\n    return strats.methods(parentVal, childVal);\n};\n\n// extend strategy\nstrats.computed =\nstrats.methods = function (parentVal, childVal) {\n    return childVal\n        ? parentVal\n            ? Object(lang[\"assign\"])({}, parentVal, childVal)\n            : childVal\n        : parentVal;\n};\n\n// data strategy\nstrats.data = function (parentVal, childVal, vm) {\n\n    if (!vm) {\n\n        if (!childVal) {\n            return parentVal;\n        }\n\n        if (!parentVal) {\n            return childVal;\n        }\n\n        return function (vm) {\n            return mergeFnData(parentVal, childVal, vm);\n        };\n\n    }\n\n    return mergeFnData(parentVal, childVal, vm);\n};\n\nfunction mergeFnData(parentVal, childVal, vm) {\n    return strats.computed(\n        Object(lang[\"isFunction\"])(parentVal)\n            ? parentVal.call(vm, vm)\n            : parentVal,\n        Object(lang[\"isFunction\"])(childVal)\n            ? childVal.call(vm, vm)\n            : childVal\n    );\n}\n\n// default strategy\nconst defaultStrat = function (parentVal, childVal) {\n    return Object(lang[\"isUndefined\"])(childVal) ? parentVal : childVal;\n};\n\nfunction mergeOptions(parent, child, vm) {\n\n    const options = {};\n\n    if (Object(lang[\"isFunction\"])(child)) {\n        child = child.options;\n    }\n\n    if (child.extends) {\n        parent = mergeOptions(parent, child.extends, vm);\n    }\n\n    if (child.mixins) {\n        for (let i = 0, l = child.mixins.length; i < l; i++) {\n            parent = mergeOptions(parent, child.mixins[i], vm);\n        }\n    }\n\n    for (const key in parent) {\n        mergeKey(key);\n    }\n\n    for (const key in child) {\n        if (!Object(lang[\"hasOwn\"])(parent, key)) {\n            mergeKey(key);\n        }\n    }\n\n    function mergeKey(key) {\n        options[key] = (strats[key] || defaultStrat)(parent[key], child[key], vm);\n    }\n\n    return options;\n}\n\nfunction parseOptions(options, args = []) {\n\n    try {\n\n        return !options\n            ? {}\n            : Object(lang[\"startsWith\"])(options, '{')\n                ? JSON.parse(options)\n                : args.length && !Object(lang[\"includes\"])(options, ':')\n                    ? ({[args[0]]: options})\n                    : options.split(';').reduce((options, option) => {\n                        const [key, value] = option.split(/:(.*)/);\n                        if (key && !Object(lang[\"isUndefined\"])(value)) {\n                            options[key.trim()] = value.trim();\n                        }\n                        return options;\n                    }, {});\n\n    } catch (e) {\n        return {};\n    }\n\n}\n\n// CONCATENATED MODULE: ./node_modules/uikit/src/js/util/player.js\n\n\n\n\n\nlet id = 0;\n\nclass player_Player {\n\n    constructor(el) {\n        this.id = ++id;\n        this.el = Object(lang[\"toNode\"])(el);\n    }\n\n    isVideo() {\n        return this.isYoutube() || this.isVimeo() || this.isHTML5();\n    }\n\n    isHTML5() {\n        return this.el.tagName === 'VIDEO';\n    }\n\n    isIFrame() {\n        return this.el.tagName === 'IFRAME';\n    }\n\n    isYoutube() {\n        return this.isIFrame() && !!this.el.src.match(/\\/\\/.*?youtube(-nocookie)?\\.[a-z]+\\/(watch\\?v=[^&\\s]+|embed)|youtu\\.be\\/.*/);\n    }\n\n    isVimeo() {\n        return this.isIFrame() && !!this.el.src.match(/vimeo\\.com\\/video\\/.*/);\n    }\n\n    enableApi() {\n\n        if (this.ready) {\n            return this.ready;\n        }\n\n        const youtube = this.isYoutube();\n        const vimeo = this.isVimeo();\n\n        let poller;\n\n        if (youtube || vimeo) {\n\n            return this.ready = new util_promise[\"Promise\"](resolve => {\n\n                once(this.el, 'load', () => {\n                    if (youtube) {\n                        const listener = () => post(this.el, {event: 'listening', id: this.id});\n                        poller = setInterval(listener, 100);\n                        listener();\n                    }\n                });\n\n                listen(data => youtube && data.id === this.id && data.event === 'onReady' || vimeo && Number(data.player_id) === this.id)\n                    .then(() => {\n                        resolve();\n                        poller && clearInterval(poller);\n                    });\n\n                attr(this.el, 'src', `${this.el.src}${Object(lang[\"includes\"])(this.el.src, '?') ? '&' : '?'}${youtube ? 'enablejsapi=1' : `api=1&player_id=${this.id}`}`);\n\n            });\n\n        }\n\n        return util_promise[\"Promise\"].resolve();\n\n    }\n\n    play() {\n\n        if (!this.isVideo()) {\n            return;\n        }\n\n        if (this.isIFrame()) {\n            this.enableApi().then(() => post(this.el, {func: 'playVideo', method: 'play'}));\n        } else if (this.isHTML5()) {\n            try {\n                const promise = this.el.play();\n\n                if (promise) {\n                    promise.catch(lang[\"noop\"]);\n                }\n            } catch (e) {}\n        }\n    }\n\n    pause() {\n\n        if (!this.isVideo()) {\n            return;\n        }\n\n        if (this.isIFrame()) {\n            this.enableApi().then(() => post(this.el, {func: 'pauseVideo', method: 'pause'}));\n        } else if (this.isHTML5()) {\n            this.el.pause();\n        }\n    }\n\n    mute() {\n\n        if (!this.isVideo()) {\n            return;\n        }\n\n        if (this.isIFrame()) {\n            this.enableApi().then(() => post(this.el, {func: 'mute', method: 'setVolume', value: 0}));\n        } else if (this.isHTML5()) {\n            this.el.muted = true;\n            attr(this.el, 'muted', '');\n        }\n\n    }\n\n}\n\nfunction post(el, cmd) {\n    try {\n        el.contentWindow.postMessage(JSON.stringify(Object(lang[\"assign\"])({event: 'command'}, cmd)), '*');\n    } catch (e) {}\n}\n\nfunction listen(cb) {\n\n    return new util_promise[\"Promise\"](resolve => {\n\n        once(window, 'message', (_, data) => resolve(data), false, ({data}) => {\n\n            if (!data || !Object(lang[\"isString\"])(data)) {\n                return;\n            }\n\n            try {\n                data = JSON.parse(data);\n            } catch (e) {\n                return;\n            }\n\n            return data && cb(data);\n\n        });\n\n    });\n\n}\n\n// CONCATENATED MODULE: ./node_modules/uikit/src/js/util/touch.js\n/*\n    Based on:\n    Copyright (c) 2010-2016 Thomas Fuchs\n    http://zeptojs.com/\n*/\n\n\n\n\n\nlet touch = {}, clickTimeout, swipeTimeout, tapTimeout, clicked;\n\nfunction swipeDirection({x1, x2, y1, y2}) {\n    return Math.abs(x1 - x2) >= Math.abs(y1 - y2) ? (x1 - x2 > 0 ? 'Left' : 'Right') : (y1 - y2 > 0 ? 'Up' : 'Down');\n}\n\nfunction cancelAll() {\n    clickTimeout && clearTimeout(clickTimeout);\n    swipeTimeout && clearTimeout(swipeTimeout);\n    tapTimeout && clearTimeout(tapTimeout);\n    clickTimeout = swipeTimeout = tapTimeout = null;\n    touch = {};\n}\n\nready(() => {\n\n    on(document, 'click', () => clicked = true, true);\n\n    on(document, pointerDown, e => {\n\n        const {target} = e;\n        const {x, y} = touch_getPos(e);\n        const now = Date.now();\n        const type = getType(e.type);\n\n        if (touch.type && touch.type !== type) {\n            return;\n        }\n\n        touch.el = 'tagName' in target ? target : target.parentNode;\n\n        clickTimeout && clearTimeout(clickTimeout);\n\n        touch.x1 = x;\n        touch.y1 = y;\n\n        if (touch.last && now - touch.last <= 250) {\n            touch = {};\n        }\n\n        touch.type = type;\n        touch.last = now;\n\n        clicked = e.button > 0;\n\n    });\n\n    on(document, pointerMove, e => {\n\n        if (e.defaultPrevented) {\n            return;\n        }\n\n        const {x, y} = touch_getPos(e);\n\n        touch.x2 = x;\n        touch.y2 = y;\n\n    });\n\n    on(document, pointerUp, ({type, target}) => {\n\n        if (touch.type !== getType(type)) {\n            return;\n        }\n\n        // swipe\n        if (touch.x2 && Math.abs(touch.x1 - touch.x2) > 30 || touch.y2 && Math.abs(touch.y1 - touch.y2) > 30) {\n\n            swipeTimeout = setTimeout(() => {\n                if (touch.el) {\n                    trigger(touch.el, 'swipe');\n                    trigger(touch.el, `swipe${swipeDirection(touch)}`);\n                }\n                touch = {};\n            });\n\n        // normal tap\n        } else if ('last' in touch) {\n\n            tapTimeout = setTimeout(() => trigger(touch.el, 'tap'));\n\n            // trigger single click after 350ms of inactivity\n            if (touch.el && type !== 'mouseup' && within(target, touch.el)) {\n                clickTimeout = setTimeout(() => {\n                    clickTimeout = null;\n                    if (touch.el && !clicked) {\n                        trigger(touch.el, 'click');\n                    }\n                    touch = {};\n                }, 350);\n            }\n\n        } else {\n            touch = {};\n        }\n\n    });\n\n    on(document, 'touchcancel', cancelAll);\n    on(window, 'scroll', cancelAll);\n\n});\n\nlet touching = false;\non(document, 'touchstart', () => touching = true, true);\non(document, 'click', () => {touching = false;});\non(document, 'touchcancel', () => touching = false, true);\n\nfunction isTouch(e) {\n    return touching || e.pointerType === 'touch';\n}\n\nfunction touch_getPos(e) {\n    const {touches, changedTouches} = e;\n    const {pageX: x, pageY: y} = touches && touches[0] || changedTouches && changedTouches[0] || e;\n\n    return {x, y};\n}\n\nfunction getType(type) {\n    return type.slice(0, 5);\n}\n\n// CONCATENATED MODULE: ./node_modules/uikit/src/js/util/index.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// CONCATENATED MODULE: ./node_modules/uikit/src/js/mixin/animate.js\n\n\nconst targetClass = 'uk-animation-target';\n\n/* harmony default export */ var mixin_animate = ({\n\n    props: {\n        animation: Number\n    },\n\n    data: {\n        animation: 150\n    },\n\n    computed: {\n\n        target() {\n            return this.$el;\n        }\n\n    },\n\n    methods: {\n\n        animate(action) {\n\n            addStyle();\n\n            let children = Object(lang[\"toNodes\"])(this.target.children);\n            let propsFrom = children.map(el => getProps(el, true));\n\n            const oldHeight = dimensions_height(this.target);\n            const oldScrollY = window.pageYOffset;\n\n            action();\n\n            Transition.cancel(this.target);\n            children.forEach(Transition.cancel);\n\n            animate_reset(this.target);\n            this.$update(this.target);\n            fastdom.flush();\n\n            const newHeight = dimensions_height(this.target);\n\n            children = children.concat(Object(lang[\"toNodes\"])(this.target.children).filter(el => !Object(lang[\"includes\"])(children, el)));\n\n            const propsTo = children.map((el, i) =>\n                el.parentNode && i in propsFrom\n                    ? propsFrom[i]\n                    ? isVisible(el)\n                        ? getPositionWithMargin(el)\n                        : {opacity: 0}\n                    : {opacity: isVisible(el) ? 1 : 0}\n                    : false\n            );\n\n            propsFrom = propsTo.map((props, i) => {\n                const from = children[i].parentNode === this.target\n                    ? propsFrom[i] || getProps(children[i])\n                    : false;\n\n                if (from) {\n                    if (!props) {\n                        delete from.opacity;\n                    } else if (!('opacity' in props)) {\n                        const {opacity} = from;\n\n                        if (opacity % 1) {\n                            props.opacity = 1;\n                        } else {\n                            delete from.opacity;\n                        }\n                    }\n                }\n\n                return from;\n            });\n\n            addClass(this.target, targetClass);\n            children.forEach((el, i) => propsFrom[i] && style_css(el, propsFrom[i]));\n            style_css(this.target, 'height', oldHeight);\n            scrollTop(window, oldScrollY);\n\n            return util_promise[\"Promise\"].all(children.map((el, i) =>\n                propsFrom[i] && propsTo[i]\n                    ? Transition.start(el, propsTo[i], this.animation, 'ease')\n                    : util_promise[\"Promise\"].resolve()\n            ).concat(Transition.start(this.target, {height: newHeight}, this.animation, 'ease'))).then(() => {\n                children.forEach((el, i) => style_css(el, {display: propsTo[i].opacity === 0 ? 'none' : '', zIndex: ''}));\n                animate_reset(this.target);\n                this.$update(this.target);\n                fastdom.flush(); // needed for IE11\n            }, lang[\"noop\"]);\n\n        }\n    }\n});\n\nfunction getProps(el, opacity) {\n\n    const zIndex = style_css(el, 'zIndex');\n\n    return isVisible(el)\n        ? Object(lang[\"assign\"])({\n            display: '',\n            opacity: opacity ? style_css(el, 'opacity') : '0',\n            pointerEvents: 'none',\n            position: 'absolute',\n            zIndex: zIndex === 'auto' ? index(el) : zIndex\n        }, getPositionWithMargin(el))\n        : false;\n}\n\nfunction animate_reset(el) {\n    style_css(el.children, {\n        height: '',\n        left: '',\n        opacity: '',\n        pointerEvents: '',\n        position: '',\n        top: '',\n        width: ''\n    });\n    removeClass(el, targetClass);\n    style_css(el, 'height', '');\n}\n\nfunction getPositionWithMargin(el) {\n    const {height, width} = el.getBoundingClientRect();\n    let {top, left} = dimensions_position(el);\n    top += Object(lang[\"toFloat\"])(style_css(el, 'marginTop'));\n\n    return {top, left, height, width};\n}\n\nlet animate_style;\n\nfunction addStyle() {\n    if (!animate_style) {\n        animate_style = append(document.head, '<style>').sheet;\n        animate_style.insertRule(\n            `.${targetClass} > * {\n                    margin-top: 0 !important;\n                    transform: none !important;\n                }`, 0\n        );\n    }\n}\n\n// CONCATENATED MODULE: ./node_modules/uikit/src/js/mixin/class.js\n\n\n/* harmony default export */ var mixin_class = ({\n\n    connected() {\n        addClass(this.$el, this.$name);\n    }\n\n});\n\n// CONCATENATED MODULE: ./node_modules/uikit/src/js/components/sortable.js\n\n\n\n\n/* harmony default export */ var components_sortable = ({\n\n    mixins: [mixin_class, mixin_animate],\n\n    props: {\n        group: String,\n        threshold: Number,\n        clsItem: String,\n        clsPlaceholder: String,\n        clsDrag: String,\n        clsDragState: String,\n        clsBase: String,\n        clsNoDrag: String,\n        clsEmpty: String,\n        clsCustom: String,\n        handle: String\n    },\n\n    data: {\n        group: false,\n        threshold: 5,\n        clsItem: 'uk-sortable-item',\n        clsPlaceholder: 'uk-sortable-placeholder',\n        clsDrag: 'uk-sortable-drag',\n        clsDragState: 'uk-drag',\n        clsBase: 'uk-sortable',\n        clsNoDrag: 'uk-sortable-nodrag',\n        clsEmpty: 'uk-sortable-empty',\n        clsCustom: '',\n        handle: false\n    },\n\n    init() {\n        ['init', 'start', 'move', 'end'].forEach(key => {\n            const fn = this[key];\n            this[key] = e => {\n                this.scrollY = window.pageYOffset;\n                const {x, y} = touch_getPos(e);\n                this.pos = {x, y};\n\n                fn(e);\n            };\n        });\n    },\n\n    events: {\n\n        [pointerDown]: 'init'\n\n    },\n\n    update: {\n\n        write() {\n\n            if (this.clsEmpty) {\n                toggleClass(this.$el, this.clsEmpty, !this.$el.children.length);\n            }\n\n            style_css(this.handle ? $$(this.handle, this.$el) : this.$el.children, 'touchAction', 'none');\n\n            if (!this.drag) {\n                return;\n            }\n\n            dimensions_offset(this.drag, {top: this.pos.y + this.origin.top, left: this.pos.x + this.origin.left});\n\n            const {top} = dimensions_offset(this.drag);\n            const bottom = top + this.drag.offsetHeight;\n            let scroll;\n\n            if (top > 0 && top < this.scrollY) {\n                scroll = this.scrollY - 5;\n            } else if (bottom < dimensions_height(document) && bottom > dimensions_height(window) + this.scrollY) {\n                scroll = this.scrollY + 5;\n            }\n\n            scroll && setTimeout(() => scrollTop(window, scroll), 5);\n        }\n\n    },\n\n    methods: {\n\n        init(e) {\n\n            const {target, button, defaultPrevented} = e;\n            const [placeholder] = Object(lang[\"toNodes\"])(this.$el.children).filter(el => within(target, el));\n\n            if (!placeholder\n                || isInput(e.target)\n                || this.handle && !within(target, this.handle)\n                || button > 0\n                || within(target, `.${this.clsNoDrag}`)\n                || defaultPrevented\n            ) {\n                return;\n            }\n\n            e.preventDefault();\n\n            this.touched = [this];\n            this.placeholder = placeholder;\n            this.origin = Object(lang[\"assign\"])({target, index: index(placeholder)}, this.pos);\n\n            on(document, pointerMove, this.move);\n            on(document, pointerUp, this.end);\n            on(window, 'scroll', this.scroll);\n\n            if (!this.threshold) {\n                this.start(e);\n            }\n\n        },\n\n        start(e) {\n\n            this.drag = append(this.$container, this.placeholder.outerHTML.replace(/^<li/i, '<div').replace(/li>$/i, 'div>'));\n\n            style_css(this.drag, Object(lang[\"assign\"])({\n                boxSizing: 'border-box',\n                width: this.placeholder.offsetWidth,\n                height: this.placeholder.offsetHeight\n            }, style_css(this.placeholder, ['paddingLeft', 'paddingRight', 'paddingTop', 'paddingBottom'])));\n            attr(this.drag, 'uk-no-boot', '');\n            addClass(this.drag, this.clsDrag, this.clsCustom);\n\n            dimensions_height(this.drag.firstElementChild, dimensions_height(this.placeholder.firstElementChild));\n\n            const {left, top} = dimensions_offset(this.placeholder);\n            Object(lang[\"assign\"])(this.origin, {left: left - this.pos.x, top: top - this.pos.y});\n\n            addClass(this.placeholder, this.clsPlaceholder);\n            addClass(this.$el.children, this.clsItem);\n            addClass(document.documentElement, this.clsDragState);\n\n            trigger(this.$el, 'start', [this, this.placeholder]);\n\n            this.move(e);\n        },\n\n        move(e) {\n\n            if (!this.drag) {\n\n                if (Math.abs(this.pos.x - this.origin.x) > this.threshold || Math.abs(this.pos.y - this.origin.y) > this.threshold) {\n                    this.start(e);\n                }\n\n                return;\n            }\n\n            this.$emit();\n\n            let target = e.type === 'mousemove' ? e.target : document.elementFromPoint(this.pos.x - document.body.scrollLeft, this.pos.y - document.body.scrollTop);\n\n            const sortable = this.getSortable(target);\n            const previous = this.getSortable(this.placeholder);\n            const move = sortable !== previous;\n\n            if (!sortable || within(target, this.placeholder) || move && (!sortable.group || sortable.group !== previous.group)) {\n                return;\n            }\n\n            target = sortable.$el === target.parentNode && target || Object(lang[\"toNodes\"])(sortable.$el.children).filter(element => within(target, element))[0];\n\n            if (move) {\n                previous.remove(this.placeholder);\n            } else if (!target) {\n                return;\n            }\n\n            sortable.insert(this.placeholder, target);\n\n            if (!Object(lang[\"includes\"])(this.touched, sortable)) {\n                this.touched.push(sortable);\n            }\n\n        },\n\n        scroll() {\n            const scroll = window.pageYOffset;\n            if (scroll !== this.scrollY) {\n                this.pos.y += scroll - this.scrollY;\n                this.scrollY = scroll;\n                this.$emit();\n            }\n        },\n\n        end(e) {\n\n            off(document, pointerMove, this.move);\n            off(document, pointerUp, this.end);\n            off(window, 'scroll', this.scroll);\n\n            if (!this.drag) {\n\n                if (e.type !== 'mouseup' && within(e.target, 'a[href]')) {\n                    location.href = closest(e.target, 'a[href]').href;\n                }\n\n                return;\n            }\n\n            preventClick();\n\n            const sortable = this.getSortable(this.placeholder);\n\n            if (this === sortable) {\n                if (this.origin.index !== index(this.placeholder)) {\n                    trigger(this.$el, 'moved', [this, this.placeholder]);\n                }\n            } else {\n                trigger(sortable.$el, 'added', [sortable, this.placeholder]);\n                trigger(this.$el, 'removed', [this, this.placeholder]);\n            }\n\n            trigger(this.$el, 'stop', [this, this.placeholder]);\n\n            remove(this.drag);\n            this.drag = null;\n\n            const classes = this.touched.map(sortable => `${sortable.clsPlaceholder} ${sortable.clsItem}`).join(' ');\n            this.touched.forEach(sortable => removeClass(sortable.$el.children, classes));\n\n            removeClass(document.documentElement, this.clsDragState);\n\n        },\n\n        insert(element, target) {\n\n            addClass(this.$el.children, this.clsItem);\n\n            const insert = () => {\n\n                if (target) {\n\n                    if (!within(element, this.$el) || isPredecessor(element, target)) {\n                        before(target, element);\n                    } else {\n                        after(target, element);\n                    }\n\n                } else {\n                    append(this.$el, element);\n                }\n\n            };\n\n            if (this.animation) {\n                this.animate(insert);\n            } else {\n                insert();\n            }\n\n        },\n\n        remove(element) {\n\n            if (!within(element, this.$el)) {\n                return;\n            }\n\n            if (this.animation) {\n                this.animate(() => remove(element));\n            } else {\n                remove(element);\n            }\n\n        },\n\n        getSortable(element) {\n            return element && (this.$getComponent(element, 'sortable') || this.getSortable(element.parentNode));\n        }\n\n    }\n\n});\n\nfunction isPredecessor(element, target) {\n    return element.parentNode === target.parentNode && index(element) > index(target);\n}\n\n// CONCATENATED MODULE: ./src/js/nestable.js\n\n\n\n\nUIkit.mixin({\n    props: {\n        nestable: Number\n    },\n    data: {\n        nestable: false\n    },\n    connected() {\n        if(this.nestable) {\n            let childNestable = this.nestable > 0 ? this.nestable - 1 : this.nestable;  \n            Object(lang[\"each\"])(this.$el.children, (child) => {\n                if(typeof child == 'object') {\n                    child.ukSortableNestableGroup = append(child, '<div class=\"uk-placeholder\" uk-sortable=\"handle: .uk-sortable-handle; nestable: ' + childNestable + '\"></div>');\n                }\n            });\n        }\n    },\n    methods: {\n        move(e) {\n\n            if (!this.drag) {\n\n                if (Math.abs(this.pos.x - this.origin.x) > this.threshold || Math.abs(this.pos.y - this.origin.y) > this.threshold) {\n                    this.start(e);\n                }\n\n                return;\n            }\n\n            this.$emit();\n\n            let target = e.type === 'mousemove' ? e.target : document.elementFromPoint(this.pos.x - document.body.scrollLeft, this.pos.y - document.body.scrollTop);\n\n            const sortable = this.getSortable(target);\n            const previous = this.getSortable(this.placeholder);\n            const move = sortable !== previous;\n\n            let move_to_group = false;\n            let move_to_child = false;\n            let move_to_parent = false;\n\n            // If sortable is not defined, be cannot drop item here.\n            if(!sortable) {\n                return;\n            }\n\n            // If target was moved, we need a previous sortable object\n            if(move && !previous) {\n                return;\n            }            \n\n            // If we move the item to another sortable, this is only allowed \n            // if they have the same group or sortable is a child of previous\n            // and previous is nestable\n            if(move) {\n\n                if(sortable.group && sortable.group === previous.group) {\n                    move_to_group  = true;\n                }\n\n                if(sortable.nestable && !within(sortable.$el, this.placeholder)) {\n                    if(within(sortable.$el, previous.$el)) {\n                        move_to_child = true;\n                    }\n    \n                    if(within(previous.$el, sortable.$el)) {\n                        move_to_parent = true;\n                    }\n                }\n\n                if(!move_to_group && !move_to_child && !move_to_parent) {\n                    return;\n                }\n            }\n\n            target = sortable.$el === target.parentNode && target || Object(lang[\"toNodes\"])(sortable.$el.children).filter(element => within(target, element))[0];\n\n            if (move) {\n                previous.remove(this.placeholder);\n            } else if (!target) {\n                return;\n            }\n\n            sortable.insert(this.placeholder, target);\n\n            if (!Object(lang[\"includes\"])(this.touched, sortable)) {\n                this.touched.push(sortable);\n            }\n        }\n    }\n}, 'sortable');\n\n//# sourceURL=webpack:///./src/js/nestable.js_+_21_modules?");

/***/ })

/******/ });